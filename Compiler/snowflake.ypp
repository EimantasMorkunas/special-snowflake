%{
    #include <stdio.h>
    #include <iostream>
    #include <map>
    #include "AST/includes.hpp"
    void yyerror (char *s);
    int yylex();
    using namespace std;
    map <string, ParamStruct> paramsOfFunctions;
%}

%union
{ 
    Node* node;
    Code* code;
    Function * function;
    Block* block;
    Statement* statement;
    Expression* expression;
    Assignment* assignment;
    AssignmentBasic* assignmentBasic;
    Identifier* identifier;
    Variable* variable;
    Integer* integer;
    Parameters* params;
    Parameter* param;
    TypeName* typeName;
    string* s;
	Loop* loop;
	Range* range;
	VarOrInteger* varOrInteger;
	Logical* logical;
	Evaluation* eval;
	Bool* bb;
	BooleanExp* booleanExp;
	Identifiers* identifiers;
	EvalGroup* evalGroup;
	EvalGroupSub* evalGroupSub;
	String* strVal;
	Char* charVal;
} 

%start start
%token <node> IF
%token <node> ELSE
%token <node> LOOP
%token FUNC
%token OUT
%token <variable> VAR
%token <integer> INTEGER
%token <s> FLOAT
%token <s> CHAR
%token <s> STRING
%token RNG
%token NOT_INIT
%token ARRAY_INIT
%token <s> INT_NAME
%token <s> FLOAT_NAME
%token <s> CHAR_NAME
%token <s> STRING_NAME
%token <s> AND
%token <s> OR
%token <s> BOOLEAN
%token <s> LTE
%token <s> GTE
%token <s> EQ
%token <s> NOT_EQ
%token <s> LT
%token <s> GT

%type <block> block statements
%type <statement> statement
%type <expression> exp
%type <assignment> assignment
%type <identifier> identifier
%type <function> func
%type <code> code start
%type <typeName> typeName;
%type <params> funcParams funcParamsSub
%type <param> funcParam
%type <loop> loop
%type <range> range
%type <varOrInteger> varOrInteger
%type <logical> logical
%type <eval> eval
%type <bb> bool
%type <booleanExp> booleanExp
%type <s> logicalOperator
%type <s> comp
%type <identifiers> identifiers
%type <evalGroup> evalGroup
%type <evalGroupSub> evalGroupSub


%left '+' '-'
%left '*' '/' '%'
%left '^'

%%

start           : code                                      {$$ = $1; CodeGenContext *c = new CodeGenContext(&paramsOfFunctions); cout << $$->genCode(c) << endl; delete c;}
                ;

code            : func                                      {cout << "code" << endl; $$ = new Code(); $$->FunctionList.push_back($1);}
                | code func                                 {printf("func code\n"); $1->FunctionList.push_back($2);}

statements      : statement                                 {printf("statement\n"); $$ = new Block(); $$->StatementList.push_back($1);}
                | statements statement                      {printf("statement statements\n"); $1->StatementList.push_back($2);}
                ;
                
block           : statements                                {printf("block statements\n"); $$ = $1;}
                |                                           {$$ = new Block();}
                ;
                
statement       : assignment                                {printf("assignment\n");}
                | logical                                   {printf("logical\n");}
                | loop                                      {printf("loop\n");}
                | funcCall                                  {printf("funcCall\n");}
                ;
                
assignment      : VAR '=' exp                               {printf("simple assignment\n"); $$ = new AssignmentBasic($1, $3);}
                | VAR '=' exp ',' assignment                {printf("multiple assignemnts\n");}
                | VAR '[' varOrInteger ']' '=' exp          {printf("array element assignement\n");}
                | VAR '=' array                             {printf("array assignement\n");}
                ;

array           : ARRAY_INIT arrayExp ']'                   {printf("array with special init\n");}
                | '[' identifiers ']'                       {printf("array with standard init\n");}
                ;

arrayExp        : varOrInteger ',' identifier               {printf("array init exp w/ default\n");}
                | varOrInteger                              {printf("array init exp\n");}
                ;

exp             : identifier                                {printf("exp with ident\n"); $$ = new ExpressionBasic($1);}
                | identifier operator exp                   {printf("exp with op and exp\n");}
                | identifier operator '(' exp ')'           {printf("exp with op and (exp)\n");}
                ;

operator        : '+'                                       {printf("+\n");}
                | '-'                                       {printf("-\n");}
                | '*'                                       {printf("*\n");}
                | '/'                                       {printf("/\n");}
                | '^'                                       {printf("^\n");}
                | '%'                                       {printf("%\n");}
                ;

logical         : IF eval '{' block '}' ELSE '{' block '}'  {printf("if with else\n"); $$ = new Logical(1, $2, $4, $8, nullptr);}
                | IF eval '{' block '}' ELSE logical        {printf("if with else if\n"); $$ = new Logical(2, $2, $4, nullptr, $7);}
                | IF eval '{' block '}'                     {printf("if no else\n"); $$ = new Logical(3, $2, $4, nullptr, nullptr);}
                ;

loop            : LOOP VAR ':' range '{' block '}'          {printf("loop with range\n"); $$ = new LoopFor($2, $4, $6);}
                | LOOP eval '{' block '}'                   {printf("loop with cond\n");}
                ;

range           : varOrInteger RNG varOrInteger             {printf("range from to\n"); $$ = new Range($1, $3);}
                | varOrInteger                              {printf("range to\n"); $$ = new Range(nullptr, $1);}
                ;

eval            : bool logicalOperator eval                 {printf("joint eval\n"); $$ = new Evaluation($1, (*$2), $3);}
                | bool                                      {printf("simple eval\n"); $$ = new Evaluation($1, "", nullptr);}
                ;

booleanExp      : evalGroup                                 {printf("evalGroupI in boolean exp\n"); $$ = new BooleanExp($1, "false");}
                | BOOLEAN                                   {printf("BOOLEAN in bool exp\n"); $$ = new BooleanExp(nullptr, (*$1));}
                ;

logicalOperator : AND                                       {printf("and\n"); $$ = $1;}
                | OR                                        {printf("or\n"); $$ = $1;}
                ;
				
identifiers     : identifier                                {printf("identifiers1\n"); $$ = new Identifiers(); $$->IdentifierList.push_back($1);}
                | identifiers ',' identifier                {printf("identifiers2\n"); $1->IdentifierList.push_back($3);}
                ;

evalGroup       : identifiers comp evalGroupSub    			{printf("evalGroup\n"); $$ = new EvalGroup($1, (*$2), $3);}
                ;
                
evalGroupSub    : identifiers comp evalGroupSub    			{printf("evalGroupSub1\n"); $$ = new EvalGroupSub($1, (*$2), $3);}
                | identifiers                      			{printf("evalGroupSub2\n"); $$ = new EvalGroupSub($1, "", nullptr);}
                ;

comp            : LT                                       	{printf("lt\n"); $$ = $1;}
                | GT                                       	{printf("gt\n"); $$ = $1;}
                | LTE                                       {printf("lte\n"); $$ = $1;}
                | GTE                                       {printf("gte\n"); $$ = $1;}
                | EQ                                        {printf("eq\n"); $$ = $1;}
                | NOT_EQ                                    {printf("noteq\n"); $$ = $1;}
                ;

number          : INTEGER                                   {printf("int in number\n"); }
                | FLOAT                                     {printf("float in number\n");}
                ;

identifier      : VAR                                       {printf("var ident\n"); $$ = new Variable(*$1);}
                | number                                    {printf("number ident\n"); }
                | CHAR                                      {printf("char ident\n"); $$ = new Char(*$1);}
                | STRING                                    {printf("string ident\n"); $$ = new String(*$1);}
                ;

varOrInteger    : VAR                                       {printf("funcCall\n"); $$ = new VarOrInteger($1, nullptr);}
                | INTEGER                                   {printf("funcCall\n"); $$ = new VarOrInteger(nullptr, $1);}
                ;

bool            : booleanExp                                {printf("funcCall\n"); $$ = new Bool($1, false);}
                | NOT_INIT booleanExp ')'                   {printf("funcCall\n"); $$ = new Bool($2, true);}
                ;

func            : FUNC VAR '(' funcParams ')' '{' block '}' {
                                                                printf("funcCall\n"); $$ = new Function($2, $4, $7);
                                                                vector<ParamStruct> params;
                                                                for(std::vector<Parameter*>::iterator it = $4->ParameterList.begin(); it != $4->ParameterList.end(); ++it) {
                                                                    params.push_back(ParamStruct(&(*it)->name->name, (*it)->type->name, (*it)->isOut));
                                                                }
                                                            }
                ;
                
funcParamsSub   : funcParam                                 {printf("funcCall\n"); $$ = new Parameters(); $$->ParameterList.push_back($1);}
                | funcParamsSub ',' funcParam               {printf("funcCall\n"); $1->ParameterList.push_back($3);}
                ;
                
funcParams      : funcParamsSub                             {printf("funcCall\n"); $$ = $1;}
                |                                           {$$ = new Parameters();}
                ;
                
funcParam       : typeName VAR                              {printf("funcCall\n"); $$ = new Parameter($2, $1, false);}
                | typeName OUT VAR                          {printf("funcCall\n"); $$ = new Parameter($3, $1, true);}
                ;
                
funcCall        : VAR '(' funcCallParams ')'                {printf("funcCall\n");}
                ;
                
funcCallParamsSub : funcCallParam                           {printf("funcCall\n");}
                  | funcCallParam ',' funcCallParamsSub     {printf("funcCall\n");}
                  ;
                    
funcCallParams  : funcCallParamsSub                         {printf("funcCall\n");}
                |
                ;                 

funcCallParam   : identifier                                {printf("funcCall\n");}
                | OUT identifier                            {printf("funcCall\n");}
                ;

typeName        : INT_NAME                                  {$$ = new TypeName($1);}
                | FLOAT_NAME                                {$$ = new TypeName($1);}
                | CHAR_NAME                                 {$$ = new TypeName($1);}
                | STRING_NAME                               {$$ = new TypeName($1);}
                ;

%%

void yyerror (char *s) {printf ("%s\n", s);}
