%{
    #include <stdio.h>
    #include <iostream>
    #include "AST/includes.hpp"
    void yyerror (char *s);
    int yylex();
    using namespace std;
%}

%union
{ 
    Node* node;
    Code* code;
    Function * function;
    Block* block;
    Statement* statement;
    Expression* expression;
    Assignment* assignment;
    AssignmentBasic* assignmentBasic;
    Identifier* identifier;
    Variable* variable;
    Integer* integer;
    Parameters* params;
    Parameter* param;
    TypeName* typeName;
    string* s;
	Loop* loop;
	Range* range;
	VarOrInteger* varOrInteger;
} 

%start code
%token <node> IF
%token <node> ELSE
%token <node> LOOP
%token FUNC
%token OUT
%token <variable> VAR
%token <integer> INTEGER
%token <s> FLOAT
%token <s> CHAR
%token <s> STRING
%token EQ
%token NOT_EQ
%token LTE
%token GTE
%token AND
%token OR
%token RNG
%token NOT_INIT
%token BOOLEAN
%token ARRAY_INIT
%token <s> INT_NAME
%token <s> FLOAT_NAME
%token <s> CHAR_NAME
%token <s> STRING_NAME

%type <block> block statements
%type <statement> statement
%type <expression> exp
%type <assignment> assignment
%type <identifier> identifier
%type <function> func
%type <code> code
%type <typeName> typeName;
%type <params> funcParams funcParamsSub
%type <param> funcParam
%type <loop> loop
%type <range> range
%type <varOrInteger> varOrInteger


%left '+' '-'
%left '*' '/' '%'
%left '^'

%%

code            : func                                      {cout << "code" << endl; $$ = new Code(); $$->FunctionList.push_back($1); cout << $$->genCode() << endl;}
                | code func                                 {printf("func code\n"); $1->FunctionList.push_back($2);}

statements      : statement                                 {printf("statement\n"); $$ = new Block(); $$->StatementList.push_back($1);}
                | statements statement                      {printf("statement statements\n"); $1->StatementList.push_back($2);}
                ;
                
block           : statements                                {printf("block statements\n"); $$ = $1;}
                |                                           {$$ = new Block();}
                ;
                
statement       : assignment                                {printf("assignment\n");}
                | logical                                   {printf("logical\n");}
                | loop                                      {printf("loop\n");}
                | funcCall                                  {printf("funcCall\n");}
                ;
                
assignment      : VAR '=' exp                               {printf("simple assignment\n"); $$ = new AssignmentBasic($1, $3);}
                | VAR '=' exp ',' assignment                {printf("multiple assignemnts\n");}
                | VAR '[' varOrInteger ']' '=' exp          {printf("array element assignement\n");}
                | VAR '=' array                             {printf("array assignement\n");}
                ;

array           : ARRAY_INIT arrayExp ']'                   {printf("array with special init\n");}
                | '[' identifiers ']'                       {printf("array with standard init\n");}
                ;

arrayExp        : varOrInteger ',' identifier               {printf("array init exp w/ default\n");}
                | varOrInteger                              {printf("array init exp\n");}
                ;

exp             : identifier                                {printf("exp with ident\n"); $$ = new ExpressionBasic($1);}
                | identifier operator exp                   {printf("exp with op and exp\n");}
                | identifier operator '(' exp ')'           {printf("exp with op and (exp)\n");}
                ;

operator        : '+'                                       {printf("+\n");}
                | '-'                                       {printf("-\n");}
                | '*'                                       {printf("*\n");}
                | '/'                                       {printf("/\n");}
                | '^'                                       {printf("^\n");}
                | '%'                                       {printf("%\n");}
                ;

logical         : IF eval '{' block '}' ELSE '{' block '}'  {printf("if with else\n");}
                | IF eval '{' block '}' ELSE logical        {printf("if with else if\n");}
                | IF eval '{' block '}'                     {printf("if no else\n");}
                ;

loop            : LOOP VAR ':' range '{' block '}'          {printf("loop with range\n"); $$ = new LoopFor($2, $4, $6);}
                | LOOP eval '{' block '}'                   {printf("loop with cond\n");}
                ;

range           : varOrInteger RNG varOrInteger             {printf("range from to\n"); $$ = new Range($1, $3);}
                | varOrInteger                              {printf("range to\n"); $$ = new Range(nullptr, $1);}
                ;

eval            : bool logicalOperator eval                 {printf("joint eval\n");}
                | bool                                      {printf("simple eval\n");}
                ;

booleanExp      : evalGroupI                                {printf("evalGroupI in boolean exp\n");}
                | BOOLEAN                                   {printf("BOOLEAN in bool exp\n");}
                ;

evalGroupI      : evalGroup                                 {printf("funcCall\n");}
                ;

logicalOperator : AND                                       {printf("funcCall\n");}
                | OR                                        {printf("funcCall\n");}
                ;

identifiers     : identifier                                {printf("funcCall\n");}
                | identifier ',' identifiers                {printf("funcCall\n");}
                ;

evalGroup       : identifiers comp evalGroupSub             {printf("funcCall\n");}
                ;
                
evalGroupSub    : identifiers comp evalGroupSub             {printf("funcCall\n");}
                | identifiers                               {printf("funcCall\n");}
                ;

comp            : '<'                                       {printf("funcCall\n");}
                | '>'                                       {printf("funcCall\n");}
                | LTE                                       {printf("funcCall\n");}
                | GTE                                       {printf("funcCall\n");}
                | EQ                                        {printf("funcCall\n");}
                | NOT_EQ                                    {printf("funcCall\n");}
                ;

number          : INTEGER                                   {printf("int in number\n");}
                | FLOAT                                     {printf("float in number\n");}
                ;

identifier      : VAR                                       {printf("var ident\n");}
                | number                                    {printf("number ident\n");}
                | CHAR                                      {printf("char ident\n");}
                | STRING                                    {printf("string ident\n");}
                ;

varOrInteger    : VAR                                       {printf("funcCall\n"); $$ = new VarOrInteger($1, nullptr);}
                | INTEGER                                   {printf("funcCall\n"); $$ = new VarOrInteger(nullptr, $1);}
                ;

bool            : booleanExp                                {printf("funcCall\n");}
                | NOT_INIT booleanExp ')'                   {printf("funcCall\n");}
                ;

func            : FUNC VAR '(' funcParams ')' '{' block '}' {printf("funcCall\n"); $$ = new Function($2, $4, $7);}
                ;
                
funcParamsSub   : funcParam                                 {printf("funcCall\n"); $$ = new Parameters(); $$->ParameterList.push_back($1);}
                | funcParamsSub ',' funcParam               {printf("funcCall\n"); $1->ParameterList.push_back($3);}
                ;
                
funcParams      : funcParamsSub                             {printf("funcCall\n"); $$ = $1;}
                |                                           {$$ = new Parameters();}
                ;
                
funcParam       : typeName VAR                              {printf("funcCall\n"); $$ = new Parameter($2, $1, false);}
                | typeName OUT VAR                          {printf("funcCall\n"); $$ = new Parameter($3, $1, true);}
                ;
                
funcCall        : VAR '(' funcCallParams ')'                {printf("funcCall\n");}
                ;
                
funcCallParamsSub : funcCallParam                           {printf("funcCall\n");}
                  | funcCallParam ',' funcCallParamsSub     {printf("funcCall\n");}
                  ;
                    
funcCallParams  : funcCallParamsSub                         {printf("funcCall\n");}
                |
                ;                 

funcCallParam   : identifier                                {printf("funcCall\n");}
                | OUT identifier                            {printf("funcCall\n");}
                ;

typeName        : INT_NAME                                  {$$ = new TypeName($1);}
                | FLOAT_NAME                                {$$ = new TypeName($1);}
                | CHAR_NAME                                 {$$ = new TypeName($1);}
                | STRING_NAME                               {$$ = new TypeName($1);}
                ;

%%

void yyerror (char *s) {printf ("%s\n", s);}
